[1mdiff --git a/abi-gen/src/type_to_string.rs b/abi-gen/src/type_to_string.rs[m
[1mindex 23e64c4..ad86d0f 100644[m
[1m--- a/abi-gen/src/type_to_string.rs[m
[1m+++ b/abi-gen/src/type_to_string.rs[m
[36m@@ -53,7 +53,8 @@[m [mprimitive_type_to_string!([m
     i32 => int32,[m
     i64 => int64,[m
     i128 => int128,[m
[31m-    i256 => int256[m
[32m+[m[32m    i256 => int256,[m[41m[m
[32m+[m[32m    FixedPointU64F16 => Fixed64x16[m[41m[m
 );[m
 seq!(N in 1..=32 {[m
     primitive_type_to_string!(Bytes#N => bytes#N);[m
[36m@@ -89,6 +90,7 @@[m [mmod tests {[m
         assert_eq!(Address::type_to_string(), "string");[m
         assert_eq!(Bytes::type_to_string(), "bytes");[m
         assert_eq!(Hash::type_to_string(), "hash");[m
[32m+[m[32m        assert_eq!(FixedPointU64F16::type_to_string(), "Fixed64x16");[m[41m[m
 [m
         seq!(N in 1..=32 {[m
             assert_eq!([m
[1mdiff --git a/examples/contract/fixed-point-simple/.gitignore b/examples/contract/fixed-point-simple/.gitignore[m
[1mnew file mode 100644[m
[1mindex 0000000..088ba6b[m
[1m--- /dev/null[m
[1m+++ b/examples/contract/fixed-point-simple/.gitignore[m
[36m@@ -0,0 +1,10 @@[m
[32m+[m[32m# Generated by Cargo[m
[32m+[m[32m# will have compiled files and executables[m
[32m+[m[32m/target/[m
[32m+[m
[32m+[m[32m# Remove Cargo.lock from gitignore if creating an executable, leave it for libraries[m
[32m+[m[32m# More information here https://doc.rust-lang.org/cargo/guide/cargo-toml-vs-cargo-lock.html[m
[32m+[m[32mCargo.lock[m
[32m+[m
[32m+[m[32m# These are backup files generated by rustfmt[m
[32m+[m[32m**/*.rs.bk[m
[1mdiff --git a/examples/contract/fixed-point-simple/.liquid/abi_gen/Cargo.toml b/examples/contract/fixed-point-simple/.liquid/abi_gen/Cargo.toml[m
[1mnew file mode 100644[m
[1mindex 0000000..cc579e4[m
[1m--- /dev/null[m
[1m+++ b/examples/contract/fixed-point-simple/.liquid/abi_gen/Cargo.toml[m
[36m@@ -0,0 +1,25 @@[m
[32m+[m[32m[package][m
[32m+[m[32mname = "abi-gen"[m
[32m+[m[32mversion = "1.0.0-rc2"[m
[32m+[m[32mauthors = ["vita-dounai <lichenxi.webank@gmail.com>"][m
[32m+[m[32medition = "2018"[m
[32m+[m[32mpublish = false[m
[32m+[m
[32m+[m[32m[[bin]][m
[32m+[m[32mname = "abi-gen"[m
[32m+[m[32mpath = "main.rs"[m
[32m+[m
[32m+[m[32m[dependencies.contract][m
[32m+[m[32mpath = "../../"[m
[32m+[m[32mpackage = "fixed-point-simple"[m
[32m+[m[32mdefault-features = false[m
[32m+[m[32mfeatures = ["liquid-abi-gen"][m
[32m+[m
[32m+[m[32m[dependencies.liquid_lang][m
[32m+[m[32mpath = "../../../../../lang"[m
[32m+[m[32mdefault-features = false[m
[32m+[m[32mfeatures = ["contract-abi-gen"][m
[32m+[m
[32m+[m[32m[dependencies][m
[32m+[m[32mserde = "1.0"[m
[32m+[m[32mserde_json = "1.0"[m
\ No newline at end of file[m
[1mdiff --git a/examples/contract/fixed-point-simple/.liquid/abi_gen/main.rs b/examples/contract/fixed-point-simple/.liquid/abi_gen/main.rs[m
[1mnew file mode 100644[m
[1mindex 0000000..d127928[m
[1m--- /dev/null[m
[1m+++ b/examples/contract/fixed-point-simple/.liquid/abi_gen/main.rs[m
[36m@@ -0,0 +1,42 @@[m
[32m+[m[32muse std::{collections::HashMap, env};[m
[32m+[m
[32m+[m[32mfn main() -> Result<(), std::io::Error> {[m
[32m+[m[32m    let mut abi = HashMap::new();[m
[32m+[m
[32m+[m[32m    let contract_abi = <contract::__LIQUID_ABI_GEN as liquid_lang::GenerateAbi>::generate_abi();[m
[32m+[m
[32m+[m[32m    let mut local_abi =[m
[32m+[m[32m        Vec::with_capacity(contract_abi.event_abis.len() + contract_abi.fn_abis.len() + 1);[m
[32m+[m[32m    local_abi.extend([m
[32m+[m[32m        contract_abi[m
[32m+[m[32m            .event_abis[m
[32m+[m[32m            .iter()[m
[32m+[m[32m            .map(|event_abi| liquid_lang::AbiKind::Event(event_abi.clone())),[m
[32m+[m[32m    );[m
[32m+[m[32m    local_abi.push(liquid_lang::AbiKind::Constructor([m
[32m+[m[32m        contract_abi.constructor_abi,[m
[32m+[m[32m    ));[m
[32m+[m[32m    local_abi.extend([m
[32m+[m[32m        contract_abi[m
[32m+[m[32m            .fn_abis[m
[32m+[m[32m            .iter()[m
[32m+[m[32m            .map(|fn_abi| liquid_lang::AbiKind::ExternalFn(fn_abi.clone())),[m
[32m+[m[32m    );[m
[32m+[m[32m    abi.insert(String::from("$local"), local_abi);[m
[32m+[m
[32m+[m[32m    for (iface_name, fn_abis) in contract_abi.iface_abis {[m
[32m+[m[32m        let fn_abis = fn_abis[m
[32m+[m[32m            .iter()[m
[32m+[m[32m            .map(|fn_abi| liquid_lang::AbiKind::ExternalFn(fn_abi.clone()))[m
[32m+[m[32m            .collect::<Vec<liquid_lang::AbiKind>>();[m
[32m+[m[32m        abi.insert(iface_name, fn_abis);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    let target_dir = env::var("CARGO_TARGET_DIR").unwrap_or("target".into());[m
[32m+[m[32m    std::fs::create_dir(&target_dir).ok();[m
[32m+[m[32m    std::fs::write([m
[32m+[m[32m        format!("{}/fixed_point_simple.abi", target_dir),[m[41m [m
[32m+[m[32m        serde_json::to_string(&abi).unwrap()[m
[32m+[m[32m    )?;[m
[32m+[m[32m    Ok(())[m
[32m+[m[32m}[m
[1mdiff --git a/examples/contract/fixed-point-simple/Cargo.toml b/examples/contract/fixed-point-simple/Cargo.toml[m
[1mnew file mode 100644[m
[1mindex 0000000..06bac38[m
[1m--- /dev/null[m
[1m+++ b/examples/contract/fixed-point-simple/Cargo.toml[m
[36m@@ -0,0 +1,61 @@[m
[32m+[m[32m[package][m
[32m+[m[32mname = "fixed-point-simple"[m
[32m+[m[32mversion = "0.1.0"[m
[32m+[m[32mauthors = ["[your_name] <you_email>"][m
[32m+[m[32medition = "2018"[m
[32m+[m
[32m+[m[32m# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html[m
[32m+[m
[32m+[m[32m[dependencies][m
[32m+[m[32mscale = { package = "parity-scale-codec", version = "1.3.1", default-features = false, features = ["derive", "full"] }[m
[32m+[m
[32m+[m[32mliquid_lang = { version = "1.0.0-rc2", path = "../../../lang", default-features = false, features = ["contract"] }[m
[32m+[m[32mliquid_primitives = { version = "1.0.0-rc2", path = "../../../primitives", default-features = false }[m
[32m+[m[32mliquid_prelude = { version = "1.0.0-rc2", path = "../../../prelude", default-features = false }[m
[32m+[m[32mliquid_macro = { version = "1.0.0-rc2", path = "../../../macro", default-features = false }[m
[32m+[m[32mliquid_abi_gen = { version = "1.0.0-rc2", path = "../../../abi-gen", default-features = false, optional = true }[m
[32m+[m
[32m+[m[32m[dev-dependencies][m
[32m+[m[32mpredicates = "1.0.5"[m
[32m+[m
[32m+[m[32m[lib][m
[32m+[m[32mname = "fixed_point_simple"[m
[32m+[m[32mcrate-type = [[m
[32m+[m[32m    # Used for normal contract Wasm blobs.[m
[32m+[m[32m    "cdylib",[m
[32m+[m[32m    # Used for ABI generation.[m
[32m+[m[32m    "rlib",[m
[32m+[m[32m][m
[32m+[m
[32m+[m[32m[features][m
[32m+[m[32mdefault = ["std"][m
[32m+[m[32mstd = [[m
[32m+[m[32m    "liquid_lang/std",[m
[32m+[m[32m    "scale/std",[m
[32m+[m[32m    "liquid_primitives/std",[m
[32m+[m[32m    "liquid_prelude/std",[m
[32m+[m[32m    "liquid_macro/std",[m
[32m+[m[32m][m
[32m+[m[32mliquid-abi-gen = [[m
[32m+[m[32m    "std",[m
[32m+[m[32m    "liquid_abi_gen",[m
[32m+[m[32m    "liquid_lang/contract-abi-gen",[m
[32m+[m[32m][m
[32m+[m[32mgm = [[m
[32m+[m[32m    "liquid_lang/gm",[m
[32m+[m[32m    "liquid_primitives/gm",[m
[32m+[m[32m][m
[32m+[m
[32m+[m[32m[profile.release][m
[32m+[m[32mpanic = "abort"[m
[32m+[m[32mlto = true[m
[32m+[m[32mopt-level = "z"[m
[32m+[m[32moverflow-checks = true[m
[32m+[m
[32m+[m[32m[workspace][m
[32m+[m[32mmembers = [[m
[32m+[m[32m    ".liquid/abi_gen",[m
[32m+[m[32m][m
[32m+[m[32mexclude = [[m
[32m+[m[32m    ".liquid",[m
[32m+[m[32m][m
[1mdiff --git a/examples/contract/fixed-point-simple/src/lib.rs b/examples/contract/fixed-point-simple/src/lib.rs[m
[1mnew file mode 100644[m
[1mindex 0000000..16be413[m
[1m--- /dev/null[m
[1m+++ b/examples/contract/fixed-point-simple/src/lib.rs[m
[36m@@ -0,0 +1,50 @@[m
[32m+[m[32m#![cfg_attr(not(feature = "std"), no_std)][m
[32m+[m
[32m+[m[32muse liquid::storage;[m
[32m+[m[32muse liquid_lang as liquid;[m
[32m+[m
[32m+[m[32m#[liquid::contract][m
[32m+[m[32mmod fixed_point_simple {[m
[32m+[m[32m    use super::*;[m
[32m+[m
[32m+[m[32m    #[liquid(storage)][m
[32m+[m[32m    struct FixedPoint {[m
[32m+[m[32m        name: storage::Value<FixedPointU64F16>,[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    #[liquid(methods)][m
[32m+[m[32m    impl FixedPoint {[m
[32m+[m[32m        pub fn new(&mut self) {[m
[32m+[m[32m            self.name.initialize(FixedPointU64F16::from_user("16.61"));[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        pub fn get(&self) -> FixedPointU64F16 {[m
[32m+[m[32m            self.name.clone()[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        pub fn set(&mut self, name: FixedPointU64F16) {[m
[32m+[m[32m            self.name.set(name)[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    #[cfg(test)][m
[32m+[m[32m    mod tests {[m
[32m+[m[32m        use super::*;[m
[32m+[m
[32m+[m[32m        #[test][m
[32m+[m[32m        fn get_works() {[m
[32m+[m[32m            let contract = FixedPoint::new();[m
[32m+[m[32m            let check = FixedPointU64F16::from_user("16.61");[m
[32m+[m[32m            assert_eq!(contract.get(), check);[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        #[test][m
[32m+[m[32m        fn set_works() {[m
[32m+[m[32m            let mut contract = FixedPoint::new();[m
[32m+[m
[32m+[m[32m            let new_name = FixedPointU64F16::from_user("4402.24");[m
[32m+[m[32m            contract.set(new_name.clone());[m
[32m+[m[32m            assert_eq!(contract.get(), new_name);[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[1mdiff --git a/lang/macro/src/utils.rs b/lang/macro/src/utils.rs[m
[1mindex f97ece8..6d3ecfa 100644[m
[1m--- a/lang/macro/src/utils.rs[m
[1m+++ b/lang/macro/src/utils.rs[m
[36m@@ -87,6 +87,7 @@[m [mpub fn generate_primitive_types() -> TokenStream2 {[m
         #fixed_size_bytes[m
 [m
         pub use liquid_primitives::types::Address;[m
[32m+[m[32m        pub use liquid_primitives::types::FixedPointU64F16;[m
         pub use liquid_primitives::types::u256;[m
         pub use liquid_primitives::types::i256;[m
         pub use liquid_primitives::types::timestamp;[m
[1mdiff --git a/lang/src/traits.rs b/lang/src/traits.rs[m
[1mindex 910f6d7..cb7b5f6 100644[m
[1m--- a/lang/src/traits.rs[m
[1m+++ b/lang/src/traits.rs[m
[36m@@ -197,7 +197,8 @@[m [mimpl_basic_trait! {[m
     String,[m
     Hash,[m
     Bytes,[m
[31m-    ()[m
[32m+[m[32m    (),[m
[32m+[m[32m    FixedPointU64F16[m
 }[m
 [m
 impl<T> You_Should_Use_An_Valid_Input_Type for Vec<T> where[m
[1mdiff --git a/lang/tests/contract/tests.rs b/lang/tests/contract/tests.rs[m
[1mindex 50d5af5..7f64f0a 100644[m
[1m--- a/lang/tests/contract/tests.rs[m
[1m+++ b/lang/tests/contract/tests.rs[m
[36m@@ -36,6 +36,7 @@[m [mfn compile_tests() {[m
     t.pass("tests/contract/ui/pass/20-vec-unit-return.rs");[m
     t.pass("tests/contract/ui/pass/21-tuple-unit-return.rs");[m
     t.pass("tests/contract/ui/pass/22-many-inputs.rs");[m
[32m+[m[32m    t.pass("tests/contract/ui/pass/23-fixed-point-simple.rs");[m
     t.compile_fail("tests/contract/ui/fail/01-constructor-returns.rs");[m
     t.compile_fail("tests/contract/ui/fail/02-missing-constructor.rs");[m
     t.compile_fail("tests/contract/ui/fail/03-multiple-constructors.rs");[m
[1mdiff --git a/lang/tests/contract/ui/pass/23-fixed-point-simple.rs b/lang/tests/contract/ui/pass/23-fixed-point-simple.rs[m
[1mnew file mode 100644[m
[1mindex 0000000..856b4d1[m
[1m--- /dev/null[m
[1m+++ b/lang/tests/contract/ui/pass/23-fixed-point-simple.rs[m
[36m@@ -0,0 +1,25 @@[m
[32m+[m[32muse liquid::storage;[m
[32m+[m[32muse liquid_lang as liquid;[m
[32m+[m
[32m+[m[32m#[liquid::contract][m
[32m+[m[32mmod noop {[m
[32m+[m[32m    use super::*;[m
[32m+[m
[32m+[m[32m    #[liquid(storage)][m
[32m+[m[32m    struct Noop {[m
[32m+[m[32m        foo: storage::Value<FixedPointU64F16>,[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    #[liquid(methods)][m
[32m+[m[32m    impl Noop {[m
[32m+[m[32m        pub fn new(&mut self) {[m
[32m+[m[32m            self.foo.initialize(Default::default());[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        pub fn noop(&self) -> FixedPointU64F16 {[m
[32m+[m[32m            FixedPointU64F16::from_user("011")[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mfn main() {}[m
[1mdiff --git a/primitives/Cargo.toml b/primitives/Cargo.toml[m
[1mindex 69c1af8..62a4015 100644[m
[1m--- a/primitives/Cargo.toml[m
[1m+++ b/primitives/Cargo.toml[m
[36m@@ -8,6 +8,7 @@[m [medition = "2018"[m
 [m
 [dependencies][m
 cfg-if = "0.1.10"[m
[32m+[m[32mfixed = "1.10.0"[m
 num = { package = "num", version = "0.3.0", default-features = false, features = ["alloc"] }[m
 num-derive = "0.3"[m
 num-traits = { package = "num-traits", version = "0.2", default-features = false }[m
[1mdiff --git a/primitives/src/types/fixed_point.rs b/primitives/src/types/fixed_point.rs[m
[1mnew file mode 100644[m
[1mindex 0000000..621ee4b[m
[1m--- /dev/null[m
[1m+++ b/primitives/src/types/fixed_point.rs[m
[36m@@ -0,0 +1,52 @@[m
[32m+[m[32m// Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m// you may not use this file except in compliance with the License.[m
[32m+[m[32m// You may obtain a copy of the License at[m
[32m+[m[32m//[m
[32m+[m[32m//     http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m//[m
[32m+[m[32m// Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m// distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m// See the License for the specific language governing permissions and[m
[32m+[m[32m// limitations under the License.[m
[32m+[m
[32m+[m[32muse liquid_macro::seq;[m
[32m+[m[32mpub use crate::types::fixed_size_bytes::*;[m
[32m+[m
[32m+[m[32m#[macro_export][m
[32m+[m[32m// macro_rules! fixed_point {[m
[32m+[m[32m//     ([m
[32m+[m[32m//         $USymbol:ty,[m[41m [m
[32m+[m[32m//         $UINT: ty,[m
[32m+[m[32m//         $UIntBytes: expr,[m
[32m+[m[32m//         $UFrac: ty,[m
[32m+[m[32m//         $UFracBytes: expr[m
[32m+[m[32m//     ) => {[m
[32m+[m[32m//         pub struct {[m
[32m+[m[32m//             wb_symbol: $USymbol,[m
[32m+[m[32m//             wb_int: $UINT,[m
[32m+[m[32m//             wb_frac: $UFrac,[m
[32m+[m[32m//         };[m
[32m+[m[32m//         impl scale::Encode for s1{[m
[32m+[m[32m//             fn encode(&Self) -> Vec<u8> {[m
[32m+[m[32m//                 wb_symbol.encode();[m
[32m+[m[32m//                 wb_int.encode();[m
[32m+[m[32m//                 wb_frac.encode()[m
[32m+[m[32m//             }[m
[32m+[m[32m//         }[m
[32m+[m[32m//     };[m
[32m+[m[32m// }[m
[32m+[m
[32m+[m[32mseq!(M in 1..3{[m
[32m+[m[32m    seq!(N in 1..=14{[m
[32m+[m[32m        // fixed_point!{[m
[32m+[m[32m        //     types1,[m
[32m+[m[32m        //     types#N,[m
[32m+[m[32m        //     stringify!(#N),[m
[32m+[m[32m        //     types#M,[m
[32m+[m[32m        //     stringify!(#M)[m
[32m+[m[32m        // }[m
[32m+[m
[32m+[m[32m    });[m
[32m+[m[32m});[m
[32m+[m
[1mdiff --git a/primitives/src/types/fixed_point_simple.rs b/primitives/src/types/fixed_point_simple.rs[m
[1mnew file mode 100644[m
[1mindex 0000000..2c11dca[m
[1m--- /dev/null[m
[1m+++ b/primitives/src/types/fixed_point_simple.rs[m
[36m@@ -0,0 +1,280 @@[m
[32m+[m[32m// Licensed under the Apache License, Version 2.0 (the "License");[m
[32m+[m[32m// you may not use this file except in compliance with the License.[m
[32m+[m[32m// You may obtain a copy of the License at[m
[32m+[m[32m//[m
[32m+[m[32m//     http://www.apache.org/licenses/LICENSE-2.0[m
[32m+[m[32m//[m
[32m+[m[32m// Unless required by applicable law or agreed to in writing, software[m
[32m+[m[32m// distributed under the License is distributed on an "AS IS" BASIS,[m
[32m+[m[32m// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.[m
[32m+[m[32m// See the License for the specific language governing permissions and[m
[32m+[m[32m// limitations under the License.[m
[32m+[m
[32m+[m[32m#[allow(unused_imports)][m
[32m+[m[32muse core::{default::Default, ops::{Add, AddAssign, Div, DivAssign, Deref, Mul, MulAssign, Sub, SubAssign}, panic, str::FromStr};[m
[32m+[m[32muse liquid_prelude::vec::{from_elem, Vec};[m
[32m+[m[32mpub use fixed::{FixedU64, types::extra::{U16}};[m
[32m+[m
[32m+[m[32m#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Default)][m
[32m+[m[32m#[cfg_attr(feature = "std", derive(Debug))][m
[32m+[m[32mpub struct FixedPointU64F16{[m
[32m+[m[32m    symbol: u8,[m[41m [m
[32m+[m[32m    value: FixedU64<U16>,[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mimpl FixedPointU64F16 {[m
[32m+[m[32m    pub fn from_be_bytes(slice: &[u8]) -> Self {[m
[32m+[m[32m        let mut bytes:[u8; 8] = [3;8];[m
[32m+[m[32m        for n in 1..9{[m
[32m+[m[32m            bytes[n-1] = slice[n];[m
[32m+[m[32m        }[m
[32m+[m[32m        Self{[m
[32m+[m[32m            symbol:slice[0],[m[41m [m
[32m+[m[32m            value: FixedU64::<U16>::from_be_bytes(bytes)[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    pub fn from_user(str: &str) -> Self{[m
[32m+[m[32m        let mut ans:FixedPointU64F16 = Default::default();[m
[32m+[m[32m        if str.chars().nth(0) == Some('-') {[m
[32m+[m[32m            ans.symbol = 255;[m
[32m+[m[32m            ans.value = FixedU64::<U16>::from_str(&str[1..]).unwrap();[m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            ans.symbol = 0;[m
[32m+[m[32m            ans.value = FixedU64::<U16>::from_str(&str[..]).unwrap();[m
[32m+[m[32m        }[m
[32m+[m[32m        if ans.value == FixedU64::<U16>::from_num(0){[m
[32m+[m[32m            ans.symbol = 0;[m
[32m+[m[32m        }[m
[32m+[m[32m        if ans.value > FixedU64::<U16>::from_num(1099511627775.99998) {[m
[32m+[m[32m            panic!("the value exceed MAX")[m
[32m+[m[32m        }[m
[32m+[m[32m        // println!("{:?}", ans);[m[41m     [m
[32m+[m[32m        ans[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m
[32m+[m[32mimpl Add for FixedPointU64F16 {[m
[32m+[m[32m    type Output = FixedPointU64F16;[m
[32m+[m[32m    fn add(self, rhs: Self) -> Self::Output {[m
[32m+[m[32m        let mut ans = self;[m
[32m+[m[32m        if self.symbol == rhs.symbol {[m
[32m+[m[32m            ans.value = rhs.value + ans.value;[m
[32m+[m[32m        }[m
[32m+[m[32m        else if ans.value == rhs.value {[m
[32m+[m[32m            ans.value = FixedU64::<U16>::from_num(0);[m
[32m+[m[32m        }[m
[32m+[m[32m        else if ans.value > rhs.value {[m
[32m+[m[32m            ans.value = ans.value - rhs.value;[m[41m            [m
[32m+[m[32m        }[m
[32m+[m[32m        else {[m
[32m+[m[32m            ans.symbol = rhs.symbol;[m
[32m+[m[32m            ans.value = rhs.value - ans.value;[m
[32m+[m[32m        }[m
[32m+[m[32m        return ans;[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m
[32m+[m[32m// impl AddAssign for FixedPointU64F16{[m
[32m+[m[32m//     fn add_assign(&mut self, rhs: Self) {[m
[32m+[m[32m//     